<html>
	<head>
		<title>Tracing voxels efficiently</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }

		</style>
	</head>
	<body>



		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>


		<script id="vertexShader" type="x-shader/x-vertex">
			precision highp float;
			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;
			attribute vec3 position;
			attribute vec3 offset;
			//attribute vec2 uv;
			attribute vec3 color;
			//varying vec2 vUv;
			varying vec3 col;
			void main() {
				//vUv = uv;
				col = color;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( offset + position, 1.0 );
			}
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">
			precision highp float;
			//uniform sampler2D map;
			//varying vec2 vUv;
			varying vec3 col;
			void main() {
				gl_FragColor = vec4(col,1.0);//texture2D(map, vUv);
			}
		</script>

		<script>

	//	var c = document.getElementById("myCanvas");
	//	var ctx = c.getContext("2d");	

		const anglesCount = 10;
		const minAngle = 0.0;
		const maxAngle = 1.0;
		const angleStep = (maxAngle - minAngle)/anglesCount;

		const velocitiesCount = 15;
		const minVelocity = 80;
		const maxVelocity = 350;
		const velocityStep = 
			(maxVelocity - minVelocity)/velocitiesCount;

		const imageTimes = [0.0, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.1, 1.01, 1.03, 1.04, 1.1];

		const trajectoryCount = anglesCount*velocitiesCount;

		// Generate trajectories
		var trajectories = [trajectoryCount];
		for (let a = 0; a<anglesCount; a++) {
			let cAngle = minAngle+a*angleStep;
			for (let v = 0; v<velocitiesCount; v++) {
				let current = {};
				let cVel = minVelocity+v*velocityStep;
				current.xv = cVel*Math.cos(cAngle);
				current.yv = cVel*Math.sin(cAngle);
				trajectories[a*velocitiesCount+v] = current;
			}
		}

		// Create list of pixels sampled by trajectories
		var samplePoints = [trajectoryCount];
		var masterList = new Map();
		for (let t = 0; t<trajectoryCount; t++) {
			let curTraj = trajectories[t];
			let curSamples = [];
			for (var img = 0; img<imageTimes.length; img++) {
				let time = imageTimes[img];
				let val = mapToSpiral(Math.floor(time*curTraj.xv), Math.floor(time*curTraj.yv), img);
				curSamples.push(val);
				if (!masterList.has(val)) {
					masterList.set(val, 1);
				} else {
					masterList.set(val, masterList.get(val)+1);
				}
			}
			samplePoints[t] = curSamples;
		}

		// Build list of pixels used multiple times
		/*
		var dupList = new Set();
		for (var [key, value] of masterList) {
			if (value > 1) {
				console.log(key + ", " + value + " Occurances");
				dupList.add(key);
			}
		}S
		*/

		// Remove samples that only 
		var components = [];
		for (var tSet of samplePoints) {
		//	components.push([...setIntersection(new Set(tSet), dupList)]); //sketchy
			components.push(tSet);
		}
		console.log("Components: ");
		console.log(components);

		// Construct tree of pixel samples
		var cTree = {};
		//cTree.pixel = 1;
		cTree.children = new Map();
		for (let i = 0; i<trajectoryCount; i++) {
			let current = cTree;
			for (let j = 0; j<components[i].length; j++) {
				let pix = components[i][j];
				current.totalChildren++;
				if (!current.children.has(pix)) {
					let t = imageTimes[j];
					current.children.set(pix, {
						x:Math.floor(t*trajectories[i].xv),
						y:Math.floor(t*trajectories[i].yv),
						depth: j,
						time: t,
						totalChildren: 0,
						children:new Map()});
				}
				current = current.children.get(pix);		
			}

		}
		cTree = cTree.children.get(1);

		console.log(cTree);

	//	console.log("trajectories");
	//	console.log(trajectories);

	//	console.log("samplePoints");
	//	console.log(samplePoints);

		// threejs setup 

		// A container to place our objects into
		var scene = new THREE.Scene();

		var width = window.innerWidth;
		var height = window.innerHeight;
		var camera = new THREE.PerspectiveCamera( 35, 
			width/height, 3, 14800 );

		// Move camera back so we are looking at the origin
		camera.position.z = -100;
		camera.lookAt(new THREE.Vector3());

		// The threejs webgl renderer
		var renderer = new THREE.WebGLRenderer({antialias: true});
		// Tell renderer the dimensions of our screen
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setClearColor(0xffffff, 1.0);
		// Attach renderer to DOM element 
		document.body.appendChild( renderer.domElement );

		// adding orbit controls to allow camera movement
		var controls = new THREE.OrbitControls( camera, renderer.domElement );
		controls.enableDamping = true;
		controls.dampingFactor = 0.25;
		controls.zoomSpeed = 0.5;
		controls.rotateSpeed = 0.4;

		var rawOffsets = [];
		var rawColors = [];
		buildChildren(cTree, rawOffsets, rawColors, 0);
		var cubeGeo = constructMeshes(rawOffsets, rawColors);

		var cubeMat = new THREE.RawShaderMaterial( {
				uniforms: {},
				vertexShader: document.getElementById( 'vertexShader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
				side: THREE.DoubleSide,
				transparent: false
			} );
		var cubesMesh = new THREE.Mesh( cubeGeo, cubeMat );
		cubesMesh.frustumCulled = false;
		scene.add( cubesMesh );

		rawVerts = [];
		rawLineCols = [];
		buildLines(cTree, rawVerts, rawColors, 0);
		var linesGeo = constructLines(rawVerts, rawColors);

		var linesMat = new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});
		var linesObj = new THREE.LineSegments(linesGeo, linesMat);
		scene.add(linesObj);

		///////////////////////////

		var render = function(){
			requestAnimationFrame(render);
			renderer.render(scene, camera);
		}

		render();

		function buildChildren(n, offs, cols, depth) {
			if (depth < 100) {
				var col;
				if (n.totalChildren<1) {
					cols.push(0);
					cols.push(0);
					cols.push(0);
				} else {
					cols.push(depth/12);
					cols.push(1-depth/12);
					cols.push(n.totalChildren/4);
				}

				offs.push(2*-n.x);
				offs.push(2*n.y);
				offs.push(imageTimes[depth]*150);

				for (var b of n.children.values()) {
					buildChildren(b, offs, cols, depth+1);
				}
			}
		}

		function buildLines(n, verts, cols, depth) {
			if (depth<5) {
				for (var b of n.children.values()) {
					verts.push(2*-n.x);
					verts.push(2*n.y);
					verts.push(imageTimes[depth]*150);
					verts.push(2*-b.x);
					verts.push(2*b.y);
					verts.push(imageTimes[depth+1]*150);
					cols.push(0.8);
					cols.push(0.4);
					cols.push(0.0);
					cols.push(0.8);
					cols.push(0.4);
					cols.push(0.0);
					buildLines(b, verts, cols, depth+1);
				}
			}
		}
		
		function constructMeshes(offsets, colors) {
			// geometry
			var instances = offsets.length/3;
			offsets = new Float32Array(offsets);
			colors = new Float32Array(colors);
			var cubeGeo = new THREE.InstancedBufferGeometry();
			// per mesh data
			var vertices = new THREE.BufferAttribute( new Float32Array( [
				// Front
				-0.8, 0.8, 0.15,
				0.8, 0.8, 0.15,
				-0.8, -0.8, 0.15,
				0.8, -0.8, 0.15,
				// Back
				0.8, 0.8, -0.15,
				-0.8, 0.8, -0.15,
				0.8, -0.8, -0.15,
				-0.8, -0.8, -0.15,
				// Left
				-0.8, 0.8, -0.15,
				-0.8, 0.8, 0.15,
				-0.8, -0.8, -0.15,
				-0.8, -0.8, 0.15,
				// Right
				0.8, 0.8, 0.15,
				0.8, 0.8, -0.15,
				0.8, -0.8, 0.15,
				0.8, -0.8, -0.15,
				// Top
				-0.8, 0.8, 0.15,
				0.8, 0.8, 0.15,
				-0.8, 0.8, -0.15,
				0.8, 0.8, -0.15,
				// Bottom
				0.8, -0.8, 0.15,
				-0.8, -0.8, 0.15,
				0.8, -0.8, -0.15,
				-0.8, -0.8, -0.15
			] ), 3 );

			cubeGeo.addAttribute( 'position', vertices );

			var indices = new Uint16Array( [
				0, 1, 2,
				2, 1, 3,
				4, 5, 6,
				6, 5, 7,
				8, 9, 10,
				10, 9, 11,
				12, 13, 14,
				14, 13, 15,
				16, 17, 18,
				18, 17, 19,
				20, 21, 22,
				22, 21, 23
			] );

			cubeGeo.setIndex( new THREE.BufferAttribute( indices, 1 ) );
			// per instance data
			var offsets = new THREE.InstancedBufferAttribute( offsets, 3, 1 );

			cubeGeo.addAttribute( 'offset', offsets ); // per mesh translation

			var colors = new THREE.InstancedBufferAttribute( colors, 3, 1 );

			cubeGeo.addAttribute( 'color', colors ); // per mesh translation
			return cubeGeo;
		}

		function constructLines(verts, col) {
	 		var linesGeo = new THREE.BufferGeometry();
	 		var vertices = new THREE.BufferAttribute(new Float32Array(verts), 3);
	 		linesGeo.addAttribute('position', vertices);
	 		var colors = new THREE.BufferAttribute(new Float32Array(col), 3);
	 		linesGeo.addAttribute('color', colors); 
	 		linesGeo.computeBoundingSphere();
	 		return linesGeo;
		}

		function mapToSpiral(x,y,z) {
			let ax = Math.abs(x);
			let ay = Math.abs(y);
			if (ax > 3000 || ay > 3000 ) console.log("X OR Y TOO BIG!");
			if (ax>ay && x>0) return 4*x*x-3*x+y+1+z*100000000;
			if (ax>ay && x<=0) return 4*x*x-x-y+1+z*100000000;
			if (ax<=ay && y>0) return 4*y*y-y-x+1+z*100000000;
			return 4*y*y-3*y+x+1+z*100000000;
		}

		// Combine sets
		function setIntersection(a,b) {
			let intersection = new Set();
			for (var elem of b) {
				if (a.has(elem)) {
					intersection.add(elem);
				}
			}
			return intersection;
		}

		// Is b contained within a?
		function setIsSuper(a,b) {
			for (var elem of b) {
				if (!a.has(elem)) {
					return false;
				}
			}
			return true;
		}

		// Subtract b from a
		function setDiff(a,b) {
			let diff = new Set(a);
			for (var elem of b) {
				diff.delete(elem);
			}
			return diff;
		}

		</script>
	</body>
</html>
